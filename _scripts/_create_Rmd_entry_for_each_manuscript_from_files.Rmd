---
output: html_document
---

# Grab meta data
```{r, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
library(tidyverse)
library(here)
library(glue)
library(fs)
library(aws.s3)

# function for human-readable filesizes
format_size <- function(imagesize){
  case_when(
    imagesize < 1000 ~ paste(imagesize, "B"),
    imagesize < 1000000 ~ paste(round(imagesize / 1000, 1), "KB"),
    imagesize < 1000000000 ~ paste(round(imagesize / 1000000, 1), "MB"),
    imagesize < 1000000000000 ~ paste(round(imagesize / 1000000000, 1), "GB"),
  )
}

# update list of content in AWS
s3_address <- "https://shakta-manuscripts.s3.eu-west-2.amazonaws.com/"

aws_content_bucket <- get_bucket("shakta-manuscripts") 

tibble(
  filepath = map_chr(aws_content_bucket, "Key"),
  filesize = map_dbl(aws_content_bucket, "Size"),
  formatted_filesize = format_size(filesize),
  manuscript = str_extract(filepath, "^[^/]+"),
  high_resolution = str_detect(filepath, "high_resolution"),
  filename = fs::path_file(filepath)
) %>% 
  mutate(filepath = paste0(s3_address, filepath)) %>% 
  write_csv(here::here("data", "aws_content.csv"))

aws_content <- read_csv(here::here("data", "aws_content.csv"))

image_counts <- aws_content %>% 
  filter(high_resolution == TRUE) %>% 
  group_by(manuscript) %>% 
  summarise(num_images = n()) %>% 
  rename(Catalogue_id = manuscript)
  
text_meta <- read_csv(here("data", "manuscripts", "manuscript_meta.csv")) %>% 
  rename(Subject = `Subject(s)`) %>% 
  left_join(image_counts)

```

# Generate Rmds
## Create the YAML header
```{r}
create_yaml_header <- function(line_of_meta_data, is_text_only_version = FALSE, image_current = FALSE){
  text_only_line <- ""
  if (is_text_only_version) text_only_line <- "\ntextOnlyVersion: yes"
  
  images_total_line <- ""
  if (!is.na(line_of_meta_data$num_images)) images_total_line <- paste0("\nimagesTotal: ", as.character(line_of_meta_data$num_images))
  
  image_current_line <- ""
  if (image_current) image_current_line <- paste0("\nimageCurrent: ", as.character(image_current))
  
  line_of_meta_data %>%  glue_data('
---
exclude_jquery: true
catalogueId: {Catalogue_id}
title: "{Identifier_popular}"
sanskritTitle: "{Title_sanskrit}"
transliteratedTitle: "{Title_transliteration}"
englishTitle: "{Title_english}"
approximateDating: "{Dating}"
manuscriptLanguage: "{Language}"
script: "{Script}"
material: "{Material}"
condition: "{Condition}"
folios: "{Folios}"
subject: "{Subject}"
physicalLocation: "{Physical_location}"
originPlace: "{Origin_place}"
author: "{Author}"
provenance: "{Provenance}"
bibliographyNote: "{Bibliography}"
codices: "{Codices}"
transliterators: "{Transliterated_by}"
translationEnglish: "{Translation_english_by}"
translationDanish: "{Translation_danish_by}"
googlesheet: "{googlesheet_with_text}"
hasPhotos: {has_photos}
hasText: {has_text}{text_only_line}{images_total_line}{image_current_line}
categories:
  - sanskrit
---

', .na = "")

}

```

## Create the body part
```{r}
create_rmd_body <- function(line_of_meta_data, has_text, has_photos, text_only_version = FALSE, image_current = FALSE){
  source_script <- case_when(
    has_text & has_photos ~ 'source(here("_scripts", "manuscript_layout.R"))',
    has_photos ~ 'source(here("_scripts", "manuscript_layout_photos_only.R"))',
    has_text ~ 'source(here("_scripts", "manuscript_layout_text_only.R"))'
  )
  
  if(has_text & !has_photos){
    read_in_data_text <- line_of_meta_data %>% glue_data('
data_text <- read_csv(here("data", "manuscripts", "{{Catalogue_id}}.csv")) %>% 
   mutate_all(~str_c("<div>", ., "</div>")) #without editableness

# count columns to include
count_cols <- data_text %>% 
  slice(1)

', .open = "{{", .close = "}}")
  } else if (has_text) {
    read_in_data_text <- line_of_meta_data %>% glue_data('
data_text <- read_csv(here("data", "manuscripts", "{{Catalogue_id}}.csv")) %>% 
   mutate(photo = str_c(photo, "{{website_photo_extension}}")) %>% 
   mutate(across(-photo, ~ str_c("<div contenteditable>", ., "</div>"))) #with editableness
   #mutate(across(-photo, ~str_c("<div>", ., "</div>"))) #without editableness

# count columns to include
count_cols <- data_text %>% 
  slice(1) %>% 
  select(-photo)

', .open = "{{", .close = "}}")
  }
  
  if (has_text){
    lines_for_including_text <- line_of_meta_data %>% glue_data('
cols_include <- count_cols %>% 
  select(chapter, transliteration, starts_with("translation_")) %>% 
  length()

cols_total <- length(count_cols)

cols_hide_nums <- c(1, seq(cols_include + 1, cols_total - 1))
', .open = "{{", .close = "}}")
    
    lines_for_including_dt_libraries <- glue('
# ensure the DT libraries are included - they are not automatically when looping through datatables
datatable(data_text, plugins = "accent-neutralise", filter = "top", extensions = c("ColReorder", "Buttons"), options = list(searchHighlight = TRUE, buttons = c("colvis", "csv", "excel", "print")))
                                             ')
  } else {
    read_in_data_text <- ""
    lines_for_including_text <- "data_text <- NA"
    lines_for_including_dt_libraries <- ""
  }
  
  if (has_photos){
    lines_for_including_photos <- line_of_meta_data %>% glue_data('
### photos to show ###
s3_address <- "https://shakta-manuscripts.s3.eu-west-2.amazonaws.com/"

aws_content <- read_csv(here::here("data", "aws_content.csv")) %>% 
  filter(manuscript == "{{Catalogue_id}}") %>% 
  mutate(filepath = paste0(s3_address, filepath))

photo_medium_info <- aws_content %>% 
  filter(str_detect(filepath, "medium_resolution"))

photo_high_info <- aws_content %>% 
  filter(str_detect(filepath, "high_resolution"))

photo_info <- tibble(
   photoid = photo_medium_info$filename,
   photo_path_medium = photo_medium_info$filepath,
   photo_size_medium = photo_medium_info$formatted_filesize,
   photo_path_high = photo_high_info$filepath,
   photo_size_high = photo_high_info$formatted_filesize) %>%
   mutate(zoomid = str_c("zoomable", row_number())) %>% 
   slice({{image_current}})
', .open = "{{", .close = "}}")
  } else {
    lines_for_including_photos <- ""
  }

  
  ### lines for JS functions ###
  explicit_jquery <- case_when(
    has_photos & !(has_text) ~ '<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>',
    TRUE ~ ''
  )
  
  overlay_divs <- case_when(
    has_text & has_photos ~ 'create_overlay_divs(photo_info, hasText = TRUE)',
    has_photos ~ 'create_overlay_divs(photo_info)',
    has_text ~ ''
  )
  
  create_content <- case_when(
    has_text & has_photos ~ 'pwalk(photo_info, create_content, cols_hide = cols_hide_nums)',
    has_photos ~ 'pwalk(photo_info, create_content)',
    has_text ~ paste0("create_content(cols_hide = cols_hide_nums, text_only_version = ", text_only_version, ")")
  )
  
  initiate_zoom_effect <- case_when(
    has_text & has_photos | has_photos ~ 'initiate_zoom_effect(photo_info)',
    has_text ~ 'create_overlay_functions()'
  )
  
  create_overlay_functions <- case_when(
    has_text & has_photos | has_photos ~ 'create_overlay_functions(photo_info)',
    has_text ~ ''
  )
  create_high_res_function <- case_when(
    has_text & has_photos | has_photos ~ 'create_high_res_function(photo_info)',
    has_text ~ ''
  )
  
  glue('
{{explicit_jquery}}

\`\`\`{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(tidyverse)
library(DT)
library(here)
library(glue)
{{source_script}}
source(here("_scripts/", "manuscript_joint_functions.R"))

{{read_in_data_text}}
{{lines_for_including_text}}
{{lines_for_including_photos}}
{{lines_for_including_dt_libraries}}

\`\`\`


\`\`\`{r add-text, results="asis"}
insert_dictionary_iframes()
{{overlay_divs}}
{{create_content}}
cat("\\n")
{{initiate_zoom_effect}}
{{create_overlay_functions}}
initialise_lazy_load()
{{create_high_res_function}}
\`\`\`
', .open = "{{", .close = "}}")
  
}


write_rmd <- function(line_of_meta_data, current_image_num = FALSE){
  folder_path <- str_c(here("content", "manuscripts", line_of_meta_data$Catalogue_id))
  dir.create(folder_path)
  
  if (line_of_meta_data$has_photos == "yes" & line_of_meta_data$has_text == "yes") {
    
    # generate an Rmd for each image
    for(cur_image in seq_along(1:line_of_meta_data$num_images)){
      yaml_header <- create_yaml_header(line_of_meta_data, image_current = cur_image)
      body_content <- create_rmd_body(line_of_meta_data, has_text = TRUE, has_photos = TRUE, image_current = cur_image)
      rmd_to_write <- str_c(yaml_header, body_content)
      
      write_lines(rmd_to_write, str_c(folder_path, "/", cur_image, ".Rmd"))
    }
    
    # write text-only version
    yaml_header <- create_yaml_header(line_of_meta_data, is_text_only_version = TRUE)
    body_content <- create_rmd_body(line_of_meta_data, has_text = TRUE, has_photos = FALSE, text_only_version = TRUE)
    rmd_to_write <- str_c(yaml_header, body_content)
    
    write_lines(rmd_to_write, str_c(folder_path, "/text-only", ".Rmd"))
    
  } else if (line_of_meta_data$has_photos == "yes" & line_of_meta_data$has_text == "no") {
    # generate an Rmd for each image
    for(cur_image in seq_along(1:line_of_meta_data$num_images)){
      yaml_header <- create_yaml_header(line_of_meta_data, image_current = cur_image)
      body_content <- create_rmd_body(line_of_meta_data, has_text = FALSE, has_photos = TRUE, image_current = cur_image)
      rmd_to_write <- str_c(yaml_header, body_content)
      
      write_lines(rmd_to_write, str_c(folder_path, "/", cur_image, ".Rmd"))
    }
    
  } else if (line_of_meta_data$has_photos == "no" & line_of_meta_data$has_text == "yes") {
    
    yaml_header <- create_yaml_header(line_of_meta_data)
    body_content <- create_rmd_body(line_of_meta_data, has_text = TRUE, has_photos = FALSE)
    rmd_to_write <- str_c(yaml_header, body_content)
    write_lines(rmd_to_write, str_c(folder_path, "/text", ".Rmd"))
  }
}

```


## Do it!

```{r}
generate_rmd <- function(text_with_meta){
  write_rmd(text_with_meta)
}

files_to_generate <- text_meta %>% 
  filter(has_content == "yes")

for(i in 1:nrow(files_to_generate)) {
  files_to_generate %>% 
    slice(i) %>% 
    generate_rmd()
}



```

